AI #5: Create facts and rules that will allow you to reason about the search problem discussed in HW 5. Your program is due before class on 3 Oct. Conceptualize a small grid (3x3) with a few obstacles and the robot and goal. Add facts and rules as required to search for the goal. Write a program that will return "finished" if there is a way from the robot to the goal. If you look at facts after this is run, you will find the nodes that were visited. If time permits, you will have an opportunity to demo your program during class. Also due on 3 Oct are the answers to the standard questions and an assigned reading from the R&N book.
My facts are:
(define facts '(goal22 visited00 obstacle11 obstacle21))
One of my rules list looks like this:
(define rules '(((visited00 goal00) (finished)) ... ))
... being one of several other rules.
You need to finish defining the rules and write two functions:
ModusPonens, which takes in a rule and checks to see if each of the symbols in the antecedent are in the facts list. If they are, you return the consequent. If not, return '(). BTW, my ModusPonens breaks each rule into its antecedent and consequent (which are both lists) and calls a helper function ModusPonens2 that calls itself recursively going through all of the symbols of the antecedent seeing if they are all facts. Remember that to check to see if -P is true you need to make sure P is not a fact. Check that ModusPonens works before going on. One more help: try (member 4 '(1 3 4 7 8)) and (member 4 '(1 3 7 8)) in your repl to see how member works. Now try (if (member 4 '(1 3 4 6 7)) 'x 'y)
Write search, which takes in an integer (call it count). It should continually go through the list of rules checking each with ModusPonens. If ModusPonens returns '() it knows that there is no new fact. If it returns the consequent, add the symbol (visited01, etc) in it to the list of facts. Since the consequent (what-is-returned) is in the form of a list, the way I did this was to set! facts to (append what-is-returned facts). This puts the new facts up front. The way I go through the rules is to try the car of rules (first rule) and then set! it to the end of the rules so that the next rule will be the next one in line. So I continually rotate through the rules. You can use count to keep track of how many rules you've gone through without making a new fact, or do the simple thing and count how many times search is called and stopping after 1000 or so (enough to make sure you've exhausted all possibilities). Return "not found" if the goal can't be reached. Return "goal found" if it can be reached. This should work on any possible 3x3 terrain, not just my example. You do not need to show the path although you could find possible paths by looking at your facts.
This is to simulate a robot thinking using the facts and rules. The use of the grid is not necessary. The program only returns text: "not found" or "goal found". It only takes one file to program. I've included one to help you get started. No other files or even functions are required; just complete the define and the functions not completed.
propSearch.ss
OK, that should be more than enough hints. Have fun, you're programming a reasoning machine.